{"ast":null,"code":"// /*\n//  * Name          : joy.js\n//  * @author       : Roberto D'Amico (Bobboteck)\n//  * Last modified : 09.06.2020\n//  * Revision      : 1.1.6\n//  *\n//  * Modification History:\n//  * Date         Version     Modified By\t\tDescription\n//  * 2020-06-09\t1.1.6\t\tRoberto D'Amico\tFixed Issue #10 and #11\n//  * 2020-04-20\t1.1.5\t\tRoberto D'Amico\tCorrect: Two sticks in a row, thanks to @liamw9534 for the suggestion\n//  * 2020-04-03               Roberto D'Amico Correct: InternalRadius when change the size of canvas, thanks to @vanslipon for the suggestion\n//  * 2020-01-07\t1.1.4\t\tRoberto D'Amico Close #6 by implementing a new parameter to set the functionality of auto-return to 0 position\n//  * 2019-11-18\t1.1.3\t\tRoberto D'Amico\tClose #5 correct indication of East direction\n//  * 2019-11-12   1.1.2       Roberto D'Amico Removed Fix #4 incorrectly introduced and restored operation with touch devices\n//  * 2019-11-12   1.1.1       Roberto D'Amico Fixed Issue #4 - Now JoyStick work in any position in the page, not only at 0,0\n//  * \n//  * The MIT License (MIT)\n//  *\n//  *  This file is part of the JoyStick Project (https://github.com/bobboteck/JoyStick).\n//  *\tCopyright (c) 2015 Roberto D'Amico (Bobboteck).\n//  *\n//  * Permission is hereby granted, free of charge, to any person obtaining a copy\n//  * of this software and associated documentation files (the \"Software\"), to deal\n//  * in the Software without restriction, including without limitation the rights\n//  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  * copies of the Software, and to permit persons to whom the Software is\n//  * furnished to do so, subject to the following conditions:\n//  * \n//  * The above copyright notice and this permission notice shall be included in all\n//  * copies or substantial portions of the Software.\n//  *\n//  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//  * SOFTWARE.\n//  */\n// /**\n//  * @desc Principal object that draw a joystick, you only need to initialize the object and suggest the HTML container\n//  * @costructor\n//  * @param container {String} - HTML object that contains the Joystick\n//  * @param parameters (optional) - object with following keys:\n//  *\ttitle {String} (optional) - The ID of canvas (Default value is 'joystick')\n//  * \twidth {Int} (optional) - The width of canvas, if not specified is setted at width of container object (Default value is the width of container object)\n//  * \theight {Int} (optional) - The height of canvas, if not specified is setted at height of container object (Default value is the height of container object)\n//  * \tinternalFillColor {String} (optional) - Internal color of Stick (Default value is '#00AA00')\n//  * \tinternalLineWidth {Int} (optional) - Border width of Stick (Default value is 2)\n//  * \tinternalStrokeColor {String}(optional) - Border color of Stick (Default value is '#003300')\n//  * \texternalLineWidth {Int} (optional) - External reference circonference width (Default value is 2)\n//  * \texternalStrokeColor {String} (optional) - External reference circonference color (Default value is '#008000')\n//  * \tautoReturnToCenter {Bool} (optional) - Sets the behavior of the stick, whether or not, it should return to zero position when released (Default value is True and return to zero)\n//  */\n// var JoyStick = (function(container, parameters)\n// {\n// \tparameters = parameters || {};\n// \tvar title = (typeof parameters.title === \"undefined\" ? \"joystick\" : parameters.title),\n// \t\twidth = (typeof parameters.width === \"undefined\" ? 0 : parameters.width),\n// \t\theight = (typeof parameters.height === \"undefined\" ? 0 : parameters.height),\n// \t\tinternalFillColor = (typeof parameters.internalFillColor === \"undefined\" ? \"#00AA00\" : parameters.internalFillColor),\n// \t\tinternalLineWidth = (typeof parameters.internalLineWidth === \"undefined\" ? 2 : parameters.internalLineWidth),\n// \t\tinternalStrokeColor = (typeof parameters.internalStrokeColor === \"undefined\" ? \"#003300\" : parameters.internalStrokeColor),\n// \t\texternalLineWidth = (typeof parameters.externalLineWidth === \"undefined\" ? 2 : parameters.externalLineWidth),\n// \t\texternalStrokeColor = (typeof parameters.externalStrokeColor ===  \"undefined\" ? \"#008000\" : parameters.externalStrokeColor),\n// \t\tautoReturnToCenter = (typeof parameters.autoReturnToCenter === \"undefined\" ? true : parameters.autoReturnToCenter);\n// \t// Create Canvas element and add it in the Container object\n// \tvar objContainer = document.getElementById(container);\n// \tvar canvas = document.createElement(\"canvas\");\n// \tcanvas.id = title;\n// \tif(width === 0) { width = objContainer.clientWidth; }\n// \tif(height === 0) { height = objContainer.clientHeight; }\n// \tcanvas.width = width;\n// \tcanvas.height = height;\n// \tobjContainer.appendChild(canvas);\n// \tvar context=canvas.getContext(\"2d\");\n// \tvar pressed = 0; // Bool - 1=Yes - 0=No\n//     var circumference = 2 * Math.PI;\n//     var internalRadius = (canvas.width-((canvas.width/2)+10))/2;\n// \tvar maxMoveStick = internalRadius + 5;\n// \tvar externalRadius = internalRadius + 30;\n// \tvar centerX = canvas.width / 2;\n// \tvar centerY = canvas.height / 2;\n// \tvar directionHorizontalLimitPos = canvas.width / 10;\n// \tvar directionHorizontalLimitNeg = directionHorizontalLimitPos * -1;\n// \tvar directionVerticalLimitPos = canvas.height / 10;\n// \tvar directionVerticalLimitNeg = directionVerticalLimitPos * -1;\n// \t// Used to save current position of stick\n// \tvar movedX=centerX;\n// \tvar movedY=centerY;\n// \t// Check if the device support the touch or not\n// \tif(\"ontouchstart\" in document.documentElement)\n// \t{\n// \t\tcanvas.addEventListener(\"touchstart\", onTouchStart, false);\n// \t\tcanvas.addEventListener(\"touchmove\", onTouchMove, false);\n// \t\tcanvas.addEventListener(\"touchend\", onTouchEnd, false);\n// \t}\n// \telse\n// \t{\n// \t\tcanvas.addEventListener(\"mousedown\", onMouseDown, false);\n// \t\tcanvas.addEventListener(\"mousemove\", onMouseMove, false);\n// \t\tcanvas.addEventListener(\"mouseup\", onMouseUp, false);\n// \t}\n// \t// Draw the object\n// \tdrawExternal();\n// \tdrawInternal();\n// \t/******************************************************\n// \t * Private methods\n// \t *****************************************************/\n// \t/**\n// \t * @desc Draw the external circle used as reference position\n// \t */\n// \tfunction drawExternal()\n// \t{\n// \t\tcontext.beginPath();\n// \t\tcontext.arc(centerX, centerY, externalRadius, 0, circumference, false);\n// \t\tcontext.lineWidth = externalLineWidth;\n// \t\tcontext.strokeStyle = externalStrokeColor;\n// \t\tcontext.stroke();\n// \t}\n// \t/**\n// \t * @desc Draw the internal stick in the current position the user have moved it\n// \t */\n// \tfunction drawInternal()\n// \t{\n// \t\tcontext.beginPath();\n// \t\tif(movedX<internalRadius) { movedX=maxMoveStick; }\n// \t\tif((movedX+internalRadius) > canvas.width) { movedX = canvas.width-(maxMoveStick); }\n// \t\tif(movedY<internalRadius) { movedY=maxMoveStick; }\n// \t\tif((movedY+internalRadius) > canvas.height) { movedY = canvas.height-(maxMoveStick); }\n// \t\tcontext.arc(movedX, movedY, internalRadius, 0, circumference, false);\n// \t\t// create radial gradient\n// \t\tvar grd = context.createRadialGradient(centerX, centerY, 5, centerX, centerY, 200);\n// \t\t// Light color\n// \t\tgrd.addColorStop(0, internalFillColor);\n// \t\t// Dark color\n// \t\tgrd.addColorStop(1, internalStrokeColor);\n// \t\tcontext.fillStyle = grd;\n// \t\tcontext.fill();\n// \t\tcontext.lineWidth = internalLineWidth;\n// \t\tcontext.strokeStyle = internalStrokeColor;\n// \t\tcontext.stroke();\n// \t}\n// \t/**\n// \t * @desc Events for manage touch\n// \t */\n// \tfunction onTouchStart(event) \n// \t{\n// \t\tpressed = 1;\n// \t}\n// \tfunction onTouchMove(event)\n// \t{\n// \t\t// Prevent the browser from doing its default thing (scroll, zoom)\n// \t\tevent.preventDefault();\n// \t\tif(pressed === 1 && event.targetTouches[0].target === canvas)\n// \t\t{\n// \t\t\tmovedX = event.targetTouches[0].pageX;\n// \t\t\tmovedY = event.targetTouches[0].pageY;\n// \t\t\t// Manage offset\n// \t\t\tif(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetTop;\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetParent.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetParent.offsetTop;\n// \t\t\t}\n// \t\t\t// Delete canvas\n// \t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t\t// Redraw object\n// \t\t\tdrawExternal();\n// \t\t\tdrawInternal();\n// \t\t}\n// \t} \n// \tfunction onTouchEnd(event) \n// \t{\n// \t\tpressed = 0;\n// \t\t// If required reset position store variable\n// \t\tif(autoReturnToCenter)\n// \t\t{\n// \t\t\tmovedX = centerX;\n// \t\t\tmovedY = centerY;\n// \t\t}\n// \t\t// Delete canvas\n// \t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t// Redraw object\n// \t\tdrawExternal();\n// \t\tdrawInternal();\n// \t\t//canvas.unbind('touchmove');\n// \t}\n// \t/**\n// \t * @desc Events for manage mouse\n// \t */\n// \tfunction onMouseDown(event) \n// \t{\n// \t\tpressed = 1;\n// \t}\n// \tfunction onMouseMove(event) \n// \t{\n// \t\tif(pressed === 1)\n// \t\t{\n// \t\t\tmovedX = event.pageX;\n// \t\t\tmovedY = event.pageY;\n// \t\t\t// Manage offset\n// \t\t\tif(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetTop;\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetParent.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetParent.offsetTop;\n// \t\t\t}\n// \t\t\t// Delete canvas\n// \t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t\t// Redraw object\n// \t\t\tdrawExternal();\n// \t\t\tdrawInternal();\n// \t\t}\n// \t}\n// \tfunction onMouseUp(event) \n// \t{\n// \t\tpressed = 0;\n// \t\t// If required reset position store variable\n// \t\tif(autoReturnToCenter)\n// \t\t{\n// \t\t\tmovedX = centerX;\n// \t\t\tmovedY = centerY;\n// \t\t}\n// \t\t// Delete canvas\n// \t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t// Redraw object\n// \t\tdrawExternal();\n// \t\tdrawInternal();\n// \t\t//canvas.unbind('mousemove');\n// \t}\n// \t/******************************************************\n// \t * Public methods\n// \t *****************************************************/\n// \t/**\n// \t * @desc The width of canvas\n// \t * @return Number of pixel width \n// \t */\n// \tthis.GetWidth = function () \n// \t{\n// \t\treturn canvas.width;\n// \t};\n// \t/**\n// \t * @desc The height of canvas\n// \t * @return Number of pixel height\n// \t */\n// \tthis.GetHeight = function () \n// \t{\n// \t\treturn canvas.height;\n// \t};\n// \t/**\n// \t * @desc The X position of the cursor relative to the canvas that contains it and to its dimensions\n// \t * @return Number that indicate relative position\n// \t */\n// \tthis.GetPosX = function ()\n// \t{\n// \t\treturn movedX;\n// \t};\n// \t/**\n// \t * @desc The Y position of the cursor relative to the canvas that contains it and to its dimensions\n// \t * @return Number that indicate relative position\n// \t */\n// \tthis.GetPosY = function ()\n// \t{\n// \t\treturn movedY;\n// \t};\n// \t/**\n// \t * @desc Normalizzed value of X move of stick\n// \t * @return Integer from -100 to +100\n// \t */\n// \tthis.GetX = function ()\n// \t{\n// \t\treturn (100*((movedX - centerX)/maxMoveStick)).toFixed();\n// \t};\n// \t/**\n// \t * @desc Normalizzed value of Y move of stick\n// \t * @return Integer from -100 to +100\n// \t */\n// \tthis.GetY = function ()\n// \t{\n// \t\treturn ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\n// \t};\n// \t/**\n// \t * @desc Get the direction of the cursor as a string that indicates the cardinal points where this is oriented\n// \t * @return String of cardinal point N, NE, E, SE, S, SW, W, NW and C when it is placed in the center\n// \t */\n// \tthis.GetDir = function()\n// \t{\n// \t\tvar result = \"\";\n// \t\tvar orizontal = movedX - centerX;\n// \t\tvar vertical = movedY - centerY;\n// \t\tif(vertical >= directionVerticalLimitNeg && vertical <= directionVerticalLimitPos)\n// \t\t{\n// \t\t\tresult = \"C\";\n// \t\t}\n// \t\tif(vertical < directionVerticalLimitNeg)\n// \t\t{\n// \t\t\tresult = \"N\";\n// \t\t}\n// \t\tif(vertical > directionVerticalLimitPos)\n// \t\t{\n// \t\t\tresult = \"S\";\n// \t\t}\n// \t\tif(orizontal < directionHorizontalLimitNeg)\n// \t\t{\n// \t\t\tif(result === \"C\")\n// \t\t\t{ \n// \t\t\t\tresult = \"W\";\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tresult += \"W\";\n// \t\t\t}\n// \t\t}\n// \t\tif(orizontal > directionHorizontalLimitPos)\n// \t\t{\n// \t\t\tif(result === \"C\")\n// \t\t\t{ \n// \t\t\t\tresult = \"E\";\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tresult += \"E\";\n// \t\t\t}\n// \t\t}\n// \t\treturn result;\n// \t};\n// });\nvar JoyStick = function JoyStick(msg) {\n  this.callputin = function () {\n    alert(msg);\n  };\n};","map":{"version":3,"sources":["/home/sagnikg/react/JazzApp/src/joy.js"],"names":["JoyStick","msg","callputin","alert"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA,IAAIA,QAAQ,GAAG,SAAXA,QAAW,CAASC,GAAT,EAAc;AAC5B,OAAKC,SAAL,GAAiB,YAAW;AAC3BC,IAAAA,KAAK,CAACF,GAAD,CAAL;AACA,GAFD;AAGA,CAJD","sourcesContent":["// /*\n//  * Name          : joy.js\n//  * @author       : Roberto D'Amico (Bobboteck)\n//  * Last modified : 09.06.2020\n//  * Revision      : 1.1.6\n//  *\n//  * Modification History:\n//  * Date         Version     Modified By\t\tDescription\n//  * 2020-06-09\t1.1.6\t\tRoberto D'Amico\tFixed Issue #10 and #11\n//  * 2020-04-20\t1.1.5\t\tRoberto D'Amico\tCorrect: Two sticks in a row, thanks to @liamw9534 for the suggestion\n//  * 2020-04-03               Roberto D'Amico Correct: InternalRadius when change the size of canvas, thanks to @vanslipon for the suggestion\n//  * 2020-01-07\t1.1.4\t\tRoberto D'Amico Close #6 by implementing a new parameter to set the functionality of auto-return to 0 position\n//  * 2019-11-18\t1.1.3\t\tRoberto D'Amico\tClose #5 correct indication of East direction\n//  * 2019-11-12   1.1.2       Roberto D'Amico Removed Fix #4 incorrectly introduced and restored operation with touch devices\n//  * 2019-11-12   1.1.1       Roberto D'Amico Fixed Issue #4 - Now JoyStick work in any position in the page, not only at 0,0\n//  * \n//  * The MIT License (MIT)\n//  *\n//  *  This file is part of the JoyStick Project (https://github.com/bobboteck/JoyStick).\n//  *\tCopyright (c) 2015 Roberto D'Amico (Bobboteck).\n//  *\n//  * Permission is hereby granted, free of charge, to any person obtaining a copy\n//  * of this software and associated documentation files (the \"Software\"), to deal\n//  * in the Software without restriction, including without limitation the rights\n//  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  * copies of the Software, and to permit persons to whom the Software is\n//  * furnished to do so, subject to the following conditions:\n//  * \n//  * The above copyright notice and this permission notice shall be included in all\n//  * copies or substantial portions of the Software.\n//  *\n//  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//  * SOFTWARE.\n//  */\n \n// /**\n//  * @desc Principal object that draw a joystick, you only need to initialize the object and suggest the HTML container\n//  * @costructor\n//  * @param container {String} - HTML object that contains the Joystick\n//  * @param parameters (optional) - object with following keys:\n//  *\ttitle {String} (optional) - The ID of canvas (Default value is 'joystick')\n//  * \twidth {Int} (optional) - The width of canvas, if not specified is setted at width of container object (Default value is the width of container object)\n//  * \theight {Int} (optional) - The height of canvas, if not specified is setted at height of container object (Default value is the height of container object)\n//  * \tinternalFillColor {String} (optional) - Internal color of Stick (Default value is '#00AA00')\n//  * \tinternalLineWidth {Int} (optional) - Border width of Stick (Default value is 2)\n//  * \tinternalStrokeColor {String}(optional) - Border color of Stick (Default value is '#003300')\n//  * \texternalLineWidth {Int} (optional) - External reference circonference width (Default value is 2)\n//  * \texternalStrokeColor {String} (optional) - External reference circonference color (Default value is '#008000')\n//  * \tautoReturnToCenter {Bool} (optional) - Sets the behavior of the stick, whether or not, it should return to zero position when released (Default value is True and return to zero)\n//  */\n// var JoyStick = (function(container, parameters)\n// {\n// \tparameters = parameters || {};\n// \tvar title = (typeof parameters.title === \"undefined\" ? \"joystick\" : parameters.title),\n// \t\twidth = (typeof parameters.width === \"undefined\" ? 0 : parameters.width),\n// \t\theight = (typeof parameters.height === \"undefined\" ? 0 : parameters.height),\n// \t\tinternalFillColor = (typeof parameters.internalFillColor === \"undefined\" ? \"#00AA00\" : parameters.internalFillColor),\n// \t\tinternalLineWidth = (typeof parameters.internalLineWidth === \"undefined\" ? 2 : parameters.internalLineWidth),\n// \t\tinternalStrokeColor = (typeof parameters.internalStrokeColor === \"undefined\" ? \"#003300\" : parameters.internalStrokeColor),\n// \t\texternalLineWidth = (typeof parameters.externalLineWidth === \"undefined\" ? 2 : parameters.externalLineWidth),\n// \t\texternalStrokeColor = (typeof parameters.externalStrokeColor ===  \"undefined\" ? \"#008000\" : parameters.externalStrokeColor),\n// \t\tautoReturnToCenter = (typeof parameters.autoReturnToCenter === \"undefined\" ? true : parameters.autoReturnToCenter);\n\t\n// \t// Create Canvas element and add it in the Container object\n// \tvar objContainer = document.getElementById(container);\n// \tvar canvas = document.createElement(\"canvas\");\n// \tcanvas.id = title;\n// \tif(width === 0) { width = objContainer.clientWidth; }\n// \tif(height === 0) { height = objContainer.clientHeight; }\n// \tcanvas.width = width;\n// \tcanvas.height = height;\n// \tobjContainer.appendChild(canvas);\n// \tvar context=canvas.getContext(\"2d\");\n\t\n// \tvar pressed = 0; // Bool - 1=Yes - 0=No\n//     var circumference = 2 * Math.PI;\n//     var internalRadius = (canvas.width-((canvas.width/2)+10))/2;\n// \tvar maxMoveStick = internalRadius + 5;\n// \tvar externalRadius = internalRadius + 30;\n// \tvar centerX = canvas.width / 2;\n// \tvar centerY = canvas.height / 2;\n// \tvar directionHorizontalLimitPos = canvas.width / 10;\n// \tvar directionHorizontalLimitNeg = directionHorizontalLimitPos * -1;\n// \tvar directionVerticalLimitPos = canvas.height / 10;\n// \tvar directionVerticalLimitNeg = directionVerticalLimitPos * -1;\n// \t// Used to save current position of stick\n// \tvar movedX=centerX;\n// \tvar movedY=centerY;\n\t\t\n// \t// Check if the device support the touch or not\n// \tif(\"ontouchstart\" in document.documentElement)\n// \t{\n// \t\tcanvas.addEventListener(\"touchstart\", onTouchStart, false);\n// \t\tcanvas.addEventListener(\"touchmove\", onTouchMove, false);\n// \t\tcanvas.addEventListener(\"touchend\", onTouchEnd, false);\n// \t}\n// \telse\n// \t{\n// \t\tcanvas.addEventListener(\"mousedown\", onMouseDown, false);\n// \t\tcanvas.addEventListener(\"mousemove\", onMouseMove, false);\n// \t\tcanvas.addEventListener(\"mouseup\", onMouseUp, false);\n// \t}\n// \t// Draw the object\n// \tdrawExternal();\n// \tdrawInternal();\n\n// \t/******************************************************\n// \t * Private methods\n// \t *****************************************************/\n\n// \t/**\n// \t * @desc Draw the external circle used as reference position\n// \t */\n// \tfunction drawExternal()\n// \t{\n// \t\tcontext.beginPath();\n// \t\tcontext.arc(centerX, centerY, externalRadius, 0, circumference, false);\n// \t\tcontext.lineWidth = externalLineWidth;\n// \t\tcontext.strokeStyle = externalStrokeColor;\n// \t\tcontext.stroke();\n// \t}\n\n// \t/**\n// \t * @desc Draw the internal stick in the current position the user have moved it\n// \t */\n// \tfunction drawInternal()\n// \t{\n// \t\tcontext.beginPath();\n// \t\tif(movedX<internalRadius) { movedX=maxMoveStick; }\n// \t\tif((movedX+internalRadius) > canvas.width) { movedX = canvas.width-(maxMoveStick); }\n// \t\tif(movedY<internalRadius) { movedY=maxMoveStick; }\n// \t\tif((movedY+internalRadius) > canvas.height) { movedY = canvas.height-(maxMoveStick); }\n// \t\tcontext.arc(movedX, movedY, internalRadius, 0, circumference, false);\n// \t\t// create radial gradient\n// \t\tvar grd = context.createRadialGradient(centerX, centerY, 5, centerX, centerY, 200);\n// \t\t// Light color\n// \t\tgrd.addColorStop(0, internalFillColor);\n// \t\t// Dark color\n// \t\tgrd.addColorStop(1, internalStrokeColor);\n// \t\tcontext.fillStyle = grd;\n// \t\tcontext.fill();\n// \t\tcontext.lineWidth = internalLineWidth;\n// \t\tcontext.strokeStyle = internalStrokeColor;\n// \t\tcontext.stroke();\n// \t}\n\t\n// \t/**\n// \t * @desc Events for manage touch\n// \t */\n// \tfunction onTouchStart(event) \n// \t{\n// \t\tpressed = 1;\n// \t}\n\n// \tfunction onTouchMove(event)\n// \t{\n// \t\t// Prevent the browser from doing its default thing (scroll, zoom)\n// \t\tevent.preventDefault();\n// \t\tif(pressed === 1 && event.targetTouches[0].target === canvas)\n// \t\t{\n// \t\t\tmovedX = event.targetTouches[0].pageX;\n// \t\t\tmovedY = event.targetTouches[0].pageY;\n// \t\t\t// Manage offset\n// \t\t\tif(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetTop;\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetParent.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetParent.offsetTop;\n// \t\t\t}\n// \t\t\t// Delete canvas\n// \t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t\t// Redraw object\n// \t\t\tdrawExternal();\n// \t\t\tdrawInternal();\n// \t\t}\n// \t} \n\n// \tfunction onTouchEnd(event) \n// \t{\n// \t\tpressed = 0;\n// \t\t// If required reset position store variable\n// \t\tif(autoReturnToCenter)\n// \t\t{\n// \t\t\tmovedX = centerX;\n// \t\t\tmovedY = centerY;\n// \t\t}\n// \t\t// Delete canvas\n// \t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t// Redraw object\n// \t\tdrawExternal();\n// \t\tdrawInternal();\n// \t\t//canvas.unbind('touchmove');\n// \t}\n\n// \t/**\n// \t * @desc Events for manage mouse\n// \t */\n// \tfunction onMouseDown(event) \n// \t{\n// \t\tpressed = 1;\n// \t}\n\n// \tfunction onMouseMove(event) \n// \t{\n// \t\tif(pressed === 1)\n// \t\t{\n// \t\t\tmovedX = event.pageX;\n// \t\t\tmovedY = event.pageY;\n// \t\t\t// Manage offset\n// \t\t\tif(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetTop;\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tmovedX -= canvas.offsetParent.offsetLeft;\n// \t\t\t\tmovedY -= canvas.offsetParent.offsetTop;\n// \t\t\t}\n// \t\t\t// Delete canvas\n// \t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t\t// Redraw object\n// \t\t\tdrawExternal();\n// \t\t\tdrawInternal();\n// \t\t}\n// \t}\n\n// \tfunction onMouseUp(event) \n// \t{\n// \t\tpressed = 0;\n// \t\t// If required reset position store variable\n// \t\tif(autoReturnToCenter)\n// \t\t{\n// \t\t\tmovedX = centerX;\n// \t\t\tmovedY = centerY;\n// \t\t}\n// \t\t// Delete canvas\n// \t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n// \t\t// Redraw object\n// \t\tdrawExternal();\n// \t\tdrawInternal();\n// \t\t//canvas.unbind('mousemove');\n// \t}\n\n// \t/******************************************************\n// \t * Public methods\n// \t *****************************************************/\n\t\n// \t/**\n// \t * @desc The width of canvas\n// \t * @return Number of pixel width \n// \t */\n// \tthis.GetWidth = function () \n// \t{\n// \t\treturn canvas.width;\n// \t};\n\t\n// \t/**\n// \t * @desc The height of canvas\n// \t * @return Number of pixel height\n// \t */\n// \tthis.GetHeight = function () \n// \t{\n// \t\treturn canvas.height;\n// \t};\n\t\n// \t/**\n// \t * @desc The X position of the cursor relative to the canvas that contains it and to its dimensions\n// \t * @return Number that indicate relative position\n// \t */\n// \tthis.GetPosX = function ()\n// \t{\n// \t\treturn movedX;\n// \t};\n\t\n// \t/**\n// \t * @desc The Y position of the cursor relative to the canvas that contains it and to its dimensions\n// \t * @return Number that indicate relative position\n// \t */\n// \tthis.GetPosY = function ()\n// \t{\n// \t\treturn movedY;\n// \t};\n\t\n// \t/**\n// \t * @desc Normalizzed value of X move of stick\n// \t * @return Integer from -100 to +100\n// \t */\n// \tthis.GetX = function ()\n// \t{\n// \t\treturn (100*((movedX - centerX)/maxMoveStick)).toFixed();\n// \t};\n\n// \t/**\n// \t * @desc Normalizzed value of Y move of stick\n// \t * @return Integer from -100 to +100\n// \t */\n// \tthis.GetY = function ()\n// \t{\n// \t\treturn ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\n// \t};\n\t\n// \t/**\n// \t * @desc Get the direction of the cursor as a string that indicates the cardinal points where this is oriented\n// \t * @return String of cardinal point N, NE, E, SE, S, SW, W, NW and C when it is placed in the center\n// \t */\n// \tthis.GetDir = function()\n// \t{\n// \t\tvar result = \"\";\n// \t\tvar orizontal = movedX - centerX;\n// \t\tvar vertical = movedY - centerY;\n\t\t\n// \t\tif(vertical >= directionVerticalLimitNeg && vertical <= directionVerticalLimitPos)\n// \t\t{\n// \t\t\tresult = \"C\";\n// \t\t}\n// \t\tif(vertical < directionVerticalLimitNeg)\n// \t\t{\n// \t\t\tresult = \"N\";\n// \t\t}\n// \t\tif(vertical > directionVerticalLimitPos)\n// \t\t{\n// \t\t\tresult = \"S\";\n// \t\t}\n\t\t\n// \t\tif(orizontal < directionHorizontalLimitNeg)\n// \t\t{\n// \t\t\tif(result === \"C\")\n// \t\t\t{ \n// \t\t\t\tresult = \"W\";\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tresult += \"W\";\n// \t\t\t}\n// \t\t}\n// \t\tif(orizontal > directionHorizontalLimitPos)\n// \t\t{\n// \t\t\tif(result === \"C\")\n// \t\t\t{ \n// \t\t\t\tresult = \"E\";\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tresult += \"E\";\n// \t\t\t}\n// \t\t}\n\t\t\n// \t\treturn result;\n// \t};\n// });\nvar JoyStick = function(msg) {\n\tthis.callputin = function() {\n\t\talert(msg);\n\t}\n}"]},"metadata":{},"sourceType":"module"}